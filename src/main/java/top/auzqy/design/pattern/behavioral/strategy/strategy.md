
## 概述 

策略模式（Strategy），定义了算法家族，分别封装起来，让他们之间可以相互替换，
此模式让算法的变化不会影响到使用算法的用户。

策略模式是一种定义了一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，
只是实现不同，他可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。


策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。
策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。

策略模式用来解耦策略的定义、创建、使用。
实际上，一个完整的策略模式就是由这三个部分组成的。

- 策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。
- 策略的创建由工厂类来完成，封装策略创建的细节。
- 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，
  有两种确定方法：编译时静态确定和运行时动态确定。
  其中，“运行时动态确定”才是策略模式最典型的应用场景。
  
除此之外，我们还可以通过策略模式来移除 if-else 分支判断。
实际上，这得益于策略工厂类，
更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。


## 示例说明

### 1. example1
商场促销 <br/>
商场搞活动，有三种促销方式: <br/>
1. 返现促销 <br/>
2. 满减促销 <br/>
3. 立减促销 <br/>

eg1_1 普通的策略模式的实现方式 <br/>
&nbsp;&nbsp;缺点：这种写法并不能完全的免除if/else的判断
    
eg1_2 结合工厂模式（演进一下） <br/>
&nbsp;&nbsp;好处/目的： <br/>
&nbsp;&nbsp;&nbsp;&nbsp;1_2.1 消除if/else的判断 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;1_2.2 避免多次创建重复的对象（比如满减啊，返现啊等这些类） <br/>

eg1_3 进一步逼真演进一下 todo
比如：
对于满减 有不同的具体的策略，比如 满100减20，满200减50 ……
对于返现 也有不同的具体的策略，比如 反20，反50等

具体的在模拟一下，如何写一个真正通用的

还可以考虑一下 反射

### 2. example2 

#### 需求
假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。
文件中只包含整型数，并且，相邻的数字通过逗号来区隔

#### 实现 

- v1：用最简单直接的方式将它实现出来
- v2：将 Sorter 类中的某些代码拆分出来，独立成职责更加单一的小类



## 博客地址 
https://www.jianshu.com/p/9c0e505b43a8



